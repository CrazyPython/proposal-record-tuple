<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record & Tuple Tutorial</title>
    <link rel="stylesheet" href="./watercss/light.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        code, pre {
            font-family:'Roboto Mono', monospace;
        }
    </style>
</head>
<body>

<h1 id="record--tuple-tutorial">Record &amp; Tuple Tutorial</h1>
<p>This tutorial will guide you through the <a href="https://github.com/tc39/proposal-record-tuple">Record &amp; Tuple ECMAScript proposal</a>.</p>
<p>üåê <strong>en</strong> | <a href="./fr.html">fr</a></p>
<hr>
<h1 id="table-of-contents">Table of contents</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#compound-values">Compound values</a></li>
<li><a href="#managing-state-with-record--tuple">Managing State with Record &amp; Tuple</a></li>
<li><a href="#keeping-track-of-objects-in-record--tuple">Keeping track of objects in Record &amp; Tuple</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<hr>
<h1 id="introduction">Introduction</h1>
<p>Hello and thanks for opening this tutorial! The goal of this page is to introduce you to Record &amp; Tuple, an experiemental feature of JavaScript.</p>
<p>In this book, you&#39;ll find multiple examples of programs that can be written using this feature.</p>
<h2 id="what-are-record--tuple-">What are Record &amp; Tuple ?</h2>
<p>A record is analoguous to an Object in JavaScript with the exception that the Record is not an Object but a deeply immutable primitive value.
Likewise, a Tuple is like an Array but is a deeply immutable primitive value.</p>
<h3 id="immutability">Immutability</h3>
<p>What do we want to say by deeply immutable primitive value?</p>
<ul>
<li>Primitive value: A string, a number or a symbol for instance are primitive values in JavaScript. Those values are in general represented as low-level values attached to the program stack.</li>
<li>Deeply immutable: It is actually a repetition as primitive values are by nature impossible to change, they are immutable. Because of that, Records or Tuples can only contain other primitive values such as strings, numbers, symbols or Records and Tuples! Those structures can be defined recursively, explaining why this immutability is deep.</li>
</ul>
<p>One could say that Record and Tuple can be described as <a href="https://2ality.com/2020/05/records-tuples-first-look.html">compound primitive values</a>.</p>
<h4 id="examples">Examples</h4>
<p>Let&#39;s start by representing a wallet in a Tuple composed of different cards represented by Records:</p>
<pre><code class="language-js">const drivingLicence = #{
    country: &quot;UK&quot;,
    number: 123456789870,
};
const creditCard = #{
    type: &quot;Amex&quot;,
    number: 378282246310005,
};
const debitCard = #{
    type: &quot;Visa&quot;,
    number: 4242424242424242,
};
const wallet = #[
    drivingLicence,
    creditCard,
    debitCard,
];</code></pre>
<p>In order to create a Record or a Tuple, just write an Object or an Array and prefix it with an hash <code>#</code> character.</p>
<blockquote>
<p>Note: You can&#39;t put objects in your wallet as your wallet is a Tuple!</p>
<pre><code class="language-js">const milesCard = {
    rank: &quot;gold&quot;,
    numero: 123456,
};
const wallet = #[
    milesCard, // TypeError
];</code></pre>
</blockquote>
<h3 id="comparisons">Comparisons</h3>
<p>The main advantage of this approach, excluding the immutability constraint, is to guarantee value equality instead of identity equality.</p>
<p>This means that you don&#39;t need to worry about which Record is being manipulated, where has it been created, etc... If its values are identical, two Records are equal. You can therefore use the <code>===</code> comparison to know if both primitive values are equal.</p>
<h4 id="example">Example</h4>
<pre><code class="language-js">const drivingLicence = #{
    country: &quot;UK&quot;,
    number: 123456789870,
};
const milesCard = {
    rank: &quot;gold&quot;,
    numero: 123456,
};

console.log(drivingLicence === #{
    country: &quot;UK&quot;,
    number: 123456789870,
}); // =&gt; true
console.log(milesCard === {
    rank: &quot;gold&quot;,
    numero: 123456,
}); // =&gt; false</code></pre>
<p>As we can see, records get matched by value instead of by identity as seen with the <code>milesCard</code>.</p>
<h2 id="introduction-looking-back">Introduction, looking back!</h2>
<p>We finally have a quick idea of what Record &amp; Tuple are for but it might be a non-trivial to know what they would be used for... We are going to explore that very soon in the next part, starting with compound values!</p>
<hr>
<h1 id="compound-values">Compound values</h1>
<p>This part is there to introduce you to the posibility to build compound values easily and how to use them.</p>
<h2 id="using-strings-to-compound-values">Using strings to compound values</h2>
<p>What we&#39;re going to do here is already possible with strings. However the ergonomics are not great.</p>
<p>Let&#39;s say we want to index items in a sparse grid and be able to look them up fast. We&#39;re going to try to encode coordinates in strings:</p>
<pre><code class="language-js">const grid = {
    &quot;0:0&quot;: &quot;player&quot;,
    &quot;3:5&quot;: &quot;enemy&quot;,
    &quot;0:1&quot;: &quot;wall&quot;,
};

console.log(&quot;at 0:0&quot;, grid[&quot;0:0&quot;]); // player</code></pre>
<p>This seems to do what we want, however, it is really easy to make a mistake:</p>
<pre><code class="language-js">const grid = {
    &quot;0:0&quot;: &quot;player&quot;,
    &quot;3:5&quot;: &quot;enemy&quot;,
    &quot;0:1&quot;: &quot;wall&quot;,
};

console.log(&quot;at 0:0x0&quot;, grid[&quot;0:0x0&quot;]); // undefined</code></pre>
<p>Changing our number representation made it impossible for us to find the location, yet, we know that <code>0 === 0x0</code>.</p>
<p>Strings let us compound values together but will leave us with their arbitrary constraints.</p>
<p>Let&#39;s look at another way we could have done this:</p>
<pre><code class="language-js">const grid = {
    &#39;{&quot;x&quot;:0,&quot;y&quot;:0}&#39;: &quot;player&quot;,
    &#39;{&quot;x&quot;:3,&quot;y&quot;:5}&#39;: &quot;enemy&quot;,
    &#39;{&quot;x&quot;:0,&quot;y&quot;:1}&#39;: &quot;wall&quot;,
};

console.log(&quot;at 0:0x0&quot;, grid[JSON.stringify({
    x: 0,
    y: 0x0,
})]); // player</code></pre>
<p>Great! this works! All we have to do is stringifying values and now we can compare things as we want. There are a few caveats though...</p>
<pre><code class="language-js">const grid = {
    &#39;{&quot;x&quot;:0,&quot;y&quot;:0}&#39;: &quot;player&quot;,
    &#39;{&quot;x&quot;:3,&quot;y&quot;:5}&#39;: &quot;enemy&quot;,
    &#39;{&quot;x&quot;:0,&quot;y&quot;:1}&#39;: &quot;wall&quot;,
};

console.log(&quot;at 0:0x0&quot;, grid[JSON.stringify({
    y: 0x0,
    x: 0,
})]); // undefined</code></pre>
<p>We&#39;re getting a wrong lookup because the order matters in JSON serialization.</p>
<h2 id="coumpounding-values-into-another-value-with-tuples">Coumpounding values into another value with tuples</h2>
<p>Fortunately we can solve those issues with Records and Tuples. Like strings, we can concatenate together some values and use them to do a bunch of things such as comparing their equality together but also using them to lookup keys. Back to our example but with tuples:</p>
<pre><code class="language-js">// We use an ES Map as they can have tuples as key values
const grid = new Map([
    [#[0, 0], &quot;player&quot;],
    [#[3, 5], &quot;enemy&quot;],
    [#[0, 1], &quot;wall&quot;],
]);

console.log(&quot;at 0:0&quot;, grid.get(#[0, 0])); // player
console.log(&quot;at 0:0&quot;, grid.get(#[0, 0x0])); // player</code></pre>
<p>Amazing! This works as expected! The difference between a tuple and a string is that a string will only keep the sequence of character information, so if one char changes, everything is off. However, the tuple will keep the actual sequence of typed values so if all the values of the tuple are identical, everything should work.</p>
<p>Now what is interesting is that you can access the internals of the tuple in a way you couldn&#39;t before and use that for equality:</p>
<pre><code class="language-js">function isAtOrigin(coordinate) {
    return coordinate === #[0, 0];
}

const c1 = #[1, 2];
const c2 = #[c1[0] - 1, c1[1] * 2 - 4];
console.log(&quot;c1 at origin?&quot;, isAtOrigin(c1)); // false
console.log(&quot;c2 at origin?&quot;, isAtOrigin(c2)); // true</code></pre>
<p>Finally, there is no need to compound values of the same type, tuples can also store a sequence of different types:</p>
<pre><code class="language-js">// Store everything!
const crazyTuple = #[&quot;hello&quot;, 123, Symbol(), #{}, #[]];
// ... except objects
const tooCrazyTuple = #[{}]; // TypeError!</code></pre>
<h2 id="coumpounding-values-into-another-value-with-records">Coumpounding values into another value with records</h2>
<p>Now let&#39;s take a quick look at records that are like tuples but keyed! Let&#39;s just name our axes from our previous example:</p>
<pre><code class="language-js">// We use an ES Map as they can have tuples as key values
const grid = new Map([
    [#{x:0, y:0}, &quot;player&quot;],
    [#{x:3, y:5}, &quot;enemy&quot;],
    [#{x:0, y:1}, &quot;wall&quot;],
]);

console.log(&quot;at 0:0&quot;, grid.get(#{x:0, y:0})); // player
console.log(&quot;at 0:0&quot;, grid.get(#{x:0, y:0x0})); // player
console.log(&quot;at 0:0&quot;, grid.get(#{y:0x0, x:0})); // player</code></pre>
<p>Note that on the last <code>console.log</code>, the order did not matter in the equality, unlike what we&#39;ve seen with converting objects to JSON.</p>
<p>The same operations from before are also possible:</p>
<pre><code class="language-js">function isAtOrigin(coordinate) {
    return coordinate === #{x:0, y:0};
}

const c1 = #{x:1, y:2};
const c2 = #{x: c1.x - 1, y: c1.y * 2 - 4 };
console.log(&quot;c1 at origin?&quot;, isAtOrigin(c1)); // false
console.log(&quot;c2 at origin?&quot;, isAtOrigin(c2)); // true</code></pre>
<p>And you can obviously store any other value in there:</p>
<pre><code class="language-js">// Store everything!
const crazyRecord = #{
    str: &quot;hello&quot;,
    nbr: 123,
    sym: Symbol(),
    rec: #{},
    tup: #[],
};
// ... except objects
const tooCrazyRecord = #{ obj: {} }; // TypeError!</code></pre>
<h2 id="coumpound-values-looking-back">Coumpound values, looking back!</h2>
<p>By this point, you should get a pretty good idea of how Record and Tuple behave. They have some nice equality properties that let us replace strings in some places. That being said, this is only a small use case for them, next, we&#39;re going to look at how we can do some state management using Record &amp; Tuple.</p>
<hr>
<h1 id="managing-state-with-record--tuple">Managing State with Record &amp; Tuple</h1>
<p>Record &amp; Tuple are great for representing state (especially shared state). For instance you could use Record &amp; Tuple to manage your <a href="https://redux.js.org/">Redux</a> state as you would use <a href="https://immutable-js.github.io/immutable-js/">Immutable.js</a> for the same thing!</p>
<h2 id="representing-immutable-state">Representing immutable state</h2>
<p>Let&#39;s start with a simple example where you store some shared state and use some functions able to lookup that state:</p>
<pre><code class="language-js">let appState = #{
    // a list of strings representing the name of each user for each visit
    userByVisit: #[
        &quot;alice&quot;,
        &quot;mike&quot;,
        &quot;alice&quot;,
    ],
    // a mapping of user to their number of visits
    visitsByUser: #{
        alice: 2,
        mike: 1,
    },
};

function getNbVisits() {
    // accessing a record and a tuple is the same as accessing objects and arrays
    return appState.userByVisit.length;
}

function getNbVisitByUser(username) {
    // computed properties work as you would expect them to!
    return appState.visitsByUser[username];
}

console.log(&quot;nb visits&quot;, getNbVisits()); // 3
console.log(&quot;nb visits by alice&quot;, getNbVisitByUser(&quot;alice&quot;)); // 2</code></pre>
<p>As we can see we have some denormalized state that is useful for the kind of lookups we want to do. Maintaining that state up to date can be hard if anyone can go and change it partially. This can happen in large codebases with mutable datastructures. Here, we can&#39;t change the datastructure so we have to mutate the state atomically, at once:</p>
<pre><code class="language-js">let appState = #{
    userByVisit: #[],
    visitsByUser: #{},
};

function getNbVisits() {
    return appState.userByVisit.length;
}

function getNbVisitByUser(username) {
    return appState.visitsByUser[username];
}

function visit(username) {
    // we swap our state with the new one
    appState = #{
        // We use pushed() to return the new appState.userByVisit record
        // after pushing a new element to it
        userByVisit: appState.userByVisit.pushed(username),
        visitsByUser: #{
            // We use the spread operation to put back the keys
            // that we had originally
            ...appState.visitsByUser,
            // But for the one that we need to change, we override it with
            // a new incremented value
            [username]: (appState.visitsByUser[username] || 0) + 1,
        }
    };
}

visit(&quot;alice&quot;);
visit(&quot;mark&quot;);
visit(&quot;alice&quot;);

console.log(&quot;nb visits&quot;, getNbVisits()); // 3
console.log(&quot;nb visits by alice&quot;, getNbVisitByUser(&quot;alice&quot;)); // 2</code></pre>
<blockquote>
<p>Note: We use an assignment to reassign the state: this is ok because the variable can have its value changed unlike the contents of the value it holds. You can try doing an assignment inside, it will fail:</p>
<pre><code class="language-js">let appState = #{
    userByVisit: #[],
    visitsByUser: #{},
};
appState.userByVisit.push(&quot;jose&quot;); // TypeError
appState.visitsByUser[&quot;jose&quot;] = 1; // TypeError (if you remove the line before)</code></pre>
</blockquote>
<blockquote>
<p>Note: using spreads to do deep reassignments can be a cumbersome task. That is why, once <a href="https://github.com/tc39/proposal-deep-path-properties-for-record/">Deep Path Properties for Record</a> advances more stages, we&#39;ll be able to feature it in this tutorial!</p>
</blockquote>
<h2 id="keeping-track-of-immutable-state-and-comparing-it">Keeping track of immutable state and comparing it</h2>
<p>Now that we have a good idea of how we want to maintain our state, we can immediately start using more of the immutability property: we can now keep around copies of our state to restore it back for later or debugging:</p>
<pre><code class="language-js">// We store our history of states in a normal array
const appStateHistory = [#{
    userByVisit: #[],
    visitsByUser: #{},
}];

// utility to get the last state in our history
function getLastState() {
    return appStateHistory[appStateHistory.length - 1];
}

function getNbVisits(appState = getLastState()) {
    return appState.userByVisit.length;
}

function getNbVisitByUser(username, appState = getLastState()) {
    return appState.visitsByUser[username];
}

function visit(username) {
    const last = getLastState();
    // we push to the array now
    appStateHistory.push(#{
        userByVisit: last.userByVisit.pushed(username),
        visitsByUser: #{
            ...last.visitsByUser,
            [username]: (last.visitsByUser[username] || 0) + 1,
        }
    });
}

visit(&quot;alice&quot;);
visit(&quot;mark&quot;);
visit(&quot;alice&quot;);

console.log(&quot;nb visits&quot;, getNbVisits()); // 3
console.log(&quot;nb visits by alice&quot;, getNbVisitByUser(&quot;alice&quot;)); // 2
// let&#39;s travel in time!
console.log(&quot;nb visits (at state 1)&quot;, getNbVisits(appStateHistory[1])); // 1
console.log(
    &quot;nb visits by alice (at state 1)&quot;,
    getNbVisitByUser(&quot;alice&quot;, appStateHistory[1])
); // 1</code></pre>
<p>Now that we can keep track of the past, let&#39;s see how we can use it with the comparison to be more efficient. We change a bit the state here and just keep track of two different pieces of state in one central state, changing one part of the state should normally not affect the rest of our app:</p>
<pre><code class="language-js">const appStateHistory = [#{
    profile: #{
        username: &quot;alice&quot;,
        fullName: &quot;Alice Ritchie&quot;,
    },
    status: #{
        message: &quot;Feeling sleepy&quot;,
        emotion: &quot;zZz&quot;,
    },
}];


function getLastState() {
    return appStateHistory[appStateHistory.length - 1];
}
// utility to get the state coming before our last state in history
// be careful! it can be undefined
function getLastLastState() {
    return appStateHistory[appStateHistory.length - 2];
}

function updateStatus(message, emotion) {
    const last = getLastState();
    appStateHistory.push(#{
        ...last,
        status: #{ message, emotion },
    });
}

function updateFullName(fullName) {
    const last = getLastState();
    appStateHistory.push(#{
        ...last,
        profile: #{
            ...last.profile,
            fullName,
        },
    });
}

function getStatusString(appState = getLastState()) {
    return `Status: ${appState.status.message} (${appState.status.emotion})`;
}

function getProfileString(appState = getLastState()) {
    return `Profile: ${appState.profile.fullName} (${appState.profile.username})`;
}

// Simulate rendering some UI (by printing in the console)
function render(prevState = getLastLastState(), newState = getLastState()) {
    console.log(&quot;=== Render Start ===&quot;);
    // Only update the profile UI if it changed!
    if (!prevState || prevState.profile !== newState.profile) {
        console.log(getProfileString());
    }
    // Only update the status UI if it changed!
    if (!prevState || prevState.status !== newState.status) {
        console.log(getStatusString());
    }
    console.log(&quot;=== Render End ===&quot;);
}

render(); // Will show both Profile and Status strings
updateStatus(&quot;Feeling Energetic!&quot;, &quot;:D&quot;);
render(); // Will only show Status string
updateFullName(&quot;Allie Ri&quot;);
render(); // Will only show Profile string</code></pre>
<p>Now we can only do expensive operations (like updating our UI) when the piece of state we&#39;re looking at changed!</p>
<h2 id="state-management-looking-back">State management, looking back!</h2>
<p>We only scratched the surface of what is possible! As we&#39;ve seen before you might want to use a state management solution like <a href="https://redux.js.org/">Redux</a> to do this. However, <a href="https://redux.js.org/">Redux</a> is not meant to give you comparison operations, you usually have to do it yourself and it is hard to get it right. With Record &amp; Tuple, comparison is done by the JavaScript engine so you don&#39;t have to do it!</p>
<hr>
<h1 id="keeping-track-of-objects-in-record--tuple">Keeping track of objects in Record &amp; Tuple</h1>
<p>As we&#39;ve seen multiple times by now, Record and Tuple will give you the dreaded <code>TypeError</code> every time you need to store an object in them.</p>
<p>THis doesn&#39;t mean you can&#39;t symbolically reference to objects in them, in this part we&#39;re going to see how!</p>
<h2 id="tracking-objects-through-indices">Tracking objects through indices</h2>
<p>Let&#39;s now imagine we have an app state that requires us to keep track of a DOM node:</p>
<pre><code class="language-js">let appState = #{
    comicSansNodes: #[
        document.body, // TypeError! DOM elements are objects
    ],
};</code></pre>
<p>What we can do is create our state so it has a <code>fixed</code> Record and Tuple part and a <code>dynamic</code> part and reference from one ot the other:</p>
<pre><code class="language-js">const appState = {
    // Record and Tuple only here:
    fixed: #{ comicSansNodes: #[] },
    // But here, you can store whatever we need!
    dynamic: [],
};

function addComicSansNode(domNode) {
    // we need to create an index and add it in the dynamic and fixed part
    const idx = appState.dynamic.length;
    appState.dynamic.push(domNode);
    appState.fixed = #{
        comicSansNodes: appState.fixed.comicSansNodes.pushed(idx),
    };
}

function makeItComic() {
    for (const idx of appState.fixed.comicSansNodes) {
        // we need to lookup our index
        const domNode = appState.dynamic[idx];
        domNode.style.fontFamily = &#39;&quot;Comic Sans MS&quot;&#39;;
    }
}

document.querySelectorAll(&quot;*&quot;).forEach(n =&gt; addComicSansNode(n));
// Finally!
makeItComic();</code></pre>
<p>Ok, as a fine observer you would tell us that this is just an array with extra steps. I&#39;m not going to lie, it&#39;s pretty much the case!</p>
<p>The only added advantage is that indices can come from any part of the &quot;fixed&quot; structure, not only the <code>comicSansNodes</code> tuple. We have one unique lookup location for our state.</p>
<h2 id="tracking-objects-more-globally-with-a-ref-bookkeeping-system">Tracking objects more globally with a ref bookkeeping system</h2>
<p>We don&#39;t really want to have to track things around so we could create a global reference bookkeeping system:</p>
<pre><code class="language-js">// A bookkeeper is a structure maintaining that references list for you
// with easy to use methods
class RefBookkeeper {
    constructor() { this._references = []; }
    ref(obj) { 
        const idx = this._references.length;
        this._references[idx] = obj;
        return idx;
    }
    deref(sym) { return this._references[sym]; }
}

globalThis.refs = new RefBookkeeper();

// Back to everything Record &amp; Tuple!
let appState = #{ comicSansNodes: #[] };

function addComicSansNode(domNode) {
    // just one state swap to do!
    appState = #{
        comicSansNodes: appState.comicSansNodes.pushed(
            // .ref() creates the index for us, we just have to store it
            refs.ref(domNode)
        ),
    };
}

function makeItComic() {
    for (const domNodeRef of appState.comicSansNodes) {
        // we need to deref the node first
        const domNode = refs.deref(domNodeRef);
        domNode.style.fontFamily = &#39;&quot;Comic Sans MS&quot;&#39;;
    }
}

document.querySelectorAll(&quot;*&quot;).forEach(n =&gt; addComicSansNode(n));
makeItComic();</code></pre>
<p>This is much more ergonomic, and again, we can start putting refs in other locations of the state, this would work.</p>
<p>That being said there is a huge caveat here: each object we track in the global refs will leak memory. There is no way around it, however, we&#39;re working on <a href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">Symbols as WeakMap Keys</a> that should let you create a global bookkeeper that doesn&#39;t leak!</p>
<pre><code class="language-js">// This snippet will not execute correctly in the playground
class RefBookkeeper {
    constructor() { this._references = new WeakMap(); }
    ref(obj) {
        // (Simplified; we may want to return an existing symbol if it&#39;s already there)
        const sym = Symbol();
        this._references.set(sym, obj);
        return sym;
    }
    deref(sym) { return this._references.get(sym); }
}
globalThis.refs = new RefBookkeeper();</code></pre>
<p>In the meantime, you should probably associate bookkeepers alongside your structures that need object referencing instead of making them global:</p>
<pre><code class="language-js">class RefBookkeeper {
    constructor() { this._references = []; }
    ref(obj) { 
        const idx = this._references.length;
        this._references[idx] = obj;
        return idx;
    }
    deref(sym) { return this._references[sym]; }
}

// now appStateRefs is module-scoped, like appState
const appStateRefs = new RefBookkeeper();

let appState = #{ comicSansNodes: #[] };

function addComicSansNode(domNode) {
    appState = #{
        comicSansNodes: appState.comicSansNodes.pushed(
            appStateRefs.ref(domNode)
        ),
    };
}

function makeItComic() {
    for (const domNodeRef of appState.comicSansNodes) {
        const domNode = appStateRefs.deref(domNodeRef);
        domNode.style.fontFamily = &#39;&quot;Comic Sans MS&quot;&#39;;
    }
}

document.querySelectorAll(&quot;*&quot;).forEach(n =&gt; addComicSansNode(n));
makeItComic();</code></pre>
<h2 id="virtual-dom-diffing-with-record-tuple-and-referencing">Virtual DOM diffing with Record, Tuple and referencing</h2>
<p>This is now an extremely advanced usage that should be abstracted away by libraries. But if you are in that space, you can use both Record &amp; Tuple and object references to compare virtual doms.</p>
<p>The main idea is to go back to the initial index tracking we&#39;ve seen at the beginning of this chapter: we keep &quot;fixed&quot; and &quot;dynamic&quot; parts separate, the fixed part describes the template part with placeholders that matches indices in the dynamic part. All we need to do is compare fixed parts to know if the general structure changed and just iterate shallowly over the dynamic part to detect changes and use that to only update the parts/placeholders of the tree that changed:</p>
<pre><code class="language-js">const emptyVdomTree = {
    fixed: null,
    dynamic: [],
};

const initialVdomTree = {
    fixed: #{
        type: &quot;ul&quot;,
        children: #[
            #{ type: &quot;li&quot;, text: &quot;Purely Static&quot; },
            #{ type: &quot;li&quot;, text: 0 },
            1,
        ]
    },
    dynamic: [
        &quot;Dynamic text&quot;,
        #{ type: &quot;li&quot;, text: &quot;Dynamic li&quot; },
    ]
};

const updatedVdomTree = {
    fixed: #{
        type: &quot;ul&quot;,
        children: #[
            #{ type: &quot;li&quot;, text: &quot;Purely Static&quot; },
            #{ type: &quot;li&quot;, text: 0 },
            1,
        ]
    },
    dynamic: [
        &quot;Dynamic text - updated!&quot;,
        #{ type: &quot;li&quot;, text: &quot;Dynamic li&quot; },
    ]
};

function getChanges(vdom1, vdom2) {
    if (vdom1.fixed !== vdom2.fixed) {
        // the whole structure changed,
        // you should probably rerender everything...
        return vdom2;
    }
    const dynamic = [];
    for (let i = 0; i &lt; vdom1.dynamic.length; i += 1) {
        if (vdom1.dynamic[i] !== vdom2.dynamic[i]) {
            dynamic.push(vdom2.dynamic[i]);
        } else {
            dynamic.push(undefined);
        }
    }
    return { dynamic };
}

console.log(getChanges(emptyVdomTree, initialVdomTree)); // full initial vdom tree
console.log(getChanges(initialVdomTree, updatedVdomTree)); // only &quot;Dynamic text - updated!&quot;</code></pre>
<p>Then it&#39;s up to our rendering library to keep track of which reference corresponds to which path in the dom, but given that info, we can figure out quite rapidly that the only thing that needs to get updated in the second <code>getChanges</code> is one piece of text!</p>
<p>This is a concept that still requires some more research and is only shallowly covered in this tutorial to show some more possible advanced usages. Don&#39;t get too hung up on it if you don&#39;t understand it.</p>
<h2 id="keeping-track-of-objects-looking-back">Keeping track of objects, looking back!</h2>
<p>This part introduces us to more advanced concepts that should be abstracted away most of the time. In general, if you can only use Record &amp; Tuple alone, that&#39;s for the best because they will give you strong guarantees, that being said, sometimes you need an escape hatch: we chose to make that escape hatch explicit so you can always trust the integrity and equality of your Records and Tuples but the drawback is that you will need to put in more work to reference/dereference non-primitive values...</p>
<hr>
<h1 id="conclusion">Conclusion</h1>
<p>Hopefully this tutorial gave you a better idea of what is possible with Record &amp; Tuple. Keep in mind this is just scratching the surface!</p>
<p>If you are still in need for more examples, we are compiling a <a href="../cookbook/index.html">cookbook</a> with a few more tricks in it!</p>


<hr/>
<nav>
    <a href="#top">^ Back to top</a>
</nav>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script type="module">
    import { bootstrapCodeSnippets } from "./bootstrap-snippets.js";
    bootstrapCodeSnippets(`Run in playground`);
</script>
</body>
</html>